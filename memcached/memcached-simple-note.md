## 部分要点

##### 二进制协议
不需要文本协议的解析处理，使得memcached性能更高

##### 分布式
将key保存在不同的服务器上


##### 性能限制
请求最大15000qps
流量400Mbps
连接数超过10000个

##### 分布式hash算法
###### 取模
求得键整数的hash值，除以服务器台数，所得的余数决定服务器
```
缺点: 当添加或者移除服务器时，缓存重组的代价相当巨大，会影响缓存命中率
```
###### 一致性哈希算法(Consistent Hashing)
首先求出memcached节点的哈希值，并将其配置到0--2^32的圆上。然后用同样的方法求出存储数据的键的hash值，并映射到圆上。然后从存储数据映射的位置顺时针查找，将数据保存到找到的第一个服务器上。
Consistent Hashing最大程度的抑制了键的重新分布，只有从增加服务器地点到逆时针相邻第一台服务器之间的键会受到影响。
有的Consistent Hashing还采用了虚拟节点的思想，使用一般hash函数的话，服务器的映射地点分布非常不均匀。使用虚拟节点为每个服务器在环上分配100--200个点，这样能抑制分布不均匀，最大限度的减小服务器增减时缓存重新分布。



## Memcached内存管理与删除机制

#### 内存碎片化
如果用C语言直接 malloc,free 来向操作系统申请和释放内存时, 在不断的申请和释放过程中,形成了一些很小的内存片断,无法再利用。 这种空闲,但无法利用内存的现象即为内存的碎片化。
  
#### Slab Allocator 缓解内存碎片化
Memcached利用Slab Allocator机制管理内存。
###### 原理
预先把内存划分成数个大小1M的slab class仓库；
再把每个仓库切分成不同尺寸的小块(chunk)；
需要存内容时,判断内容的大小,为其选取合理的仓库。

memcached根据收到的数据的大小, 选择最适合数据大小的chunk组。
memcached 中保存着 slab class 内空闲 chunk 的列表, 根据该列表选择空的 chunk, 然后将数据缓存于其中。
```
注意:如果有 100byte 的数据,但122byte大小的仓库中的chunk满了；
此时会把122byte仓库的旧数据剔除掉，然后存储[Memcachedd的删除机制]。
```

###### 固定大小chunk的内存浪费
Slab Allocator存在的问题
由于分配的是特定长度的内存，因此无法有效利用分配的内存。
例如: 将100byte数据存入128byte的chunk，则浪费了28byte。

因为不能自定义chunk的大小，所以无法彻底解决chunk空间浪费问题。
问题缓解:  如果预先知道客户端发送的数据的公用的大小，或者仅缓存大小相同的数据的情况下。只要使用适合数据大小的组的列表，就可以减少浪费。

即:  通过缓存中item长度进行统计，通过参数调整slab class大小的增长速度，即增长因子(growth factor)，从而制定合理的chunk大小。

###### Slab Allocator术语
- page – 分配给slab的内存空间,默认是1MB，分配给slab之后跟据slab大小切分成chunk
- chunk – 用于缓存数据的内存空间
- slab class – 特定大小的chunk组

###### Growth Factor调优
启动时指定growth factor因子，就可以在某种程度上控制slab之间的差异，默认值为1.25。
Memcached –f 2 –vv
(查看growth factor为2时slab中chunk size的差异)
Memcached引入时，最好重新计算一下数据的预期平均长度，调整growth factor，以获得最恰当的设置。

#### 数据删除[过期数据惰性删除]
1、Memcached不会释放已分配的内存，其存储空间可以重复使用。
2、Lazy Expiration
Memcached内部不会监视数据是否过期，而是在get时查看数据的时间戳，查看数据是否过期。被称为lazy expiration(惰性过期)。
3、当Memcached内存空间不足，即无法从slab class中获取到新的空间时，就从最近未被使用的数据中搜索，将其空间分配给新的数据。（如果要禁用LRU，使用-M参数，超出会报错）。
4、不指定具体值则默认数值为64M。
```
lazy expiration好处: 
节省CPU时间和检测成本
```

#### LRU删除机制
如果以 128byte的chunk举例, 128byte的chunk都满了, 又有新的值(长度为 120)要加入, 要剔除掉哪个数据?

**操作系统的内存管理,常用 FIFO,LRU 删除** 
- LRU: Least Recently Used 最近最少使用
- FIFO: First In ,First Out 先进先出

**memcached 使用LRU删除机制**
原理: 当某个单元被请求时,维护一个计数器,通过计数器来判断最近谁最少被使用. 就把谁剔除。
```
注: 即使某个 key 是设置的永久有效期,也一样会被踢出来!
--即永久数据被踢现象
```

#### 参数限制
- key 的长度: 250 字节, (二进制协议支持 65536 个字节)
- value 的限制: 1m, 一般都是存储一些文本,如新闻列表等等,这个值足够了. 内存的限制: 32 位下最大设置到 2g.

如果有 30G数据要缓存,一般也不会单实例装 30G, (不要把鸡蛋装在一个篮子里),，可以开启多个实例(在不同的机器,或同台机器上的不同端口)



## 分布式集群算法
##### 分布式之取模算法
###### 原理
N个Memcached节点，从0->N-1编号，key对N取模，余i，则key地i个节点上。

###### 取模算法对缓存命中率的影响
假设有8台服务器，运行中，突然down了一台，则取模底数变成了7，
则，命中率下降为原来的1/7
有 N 台服务器, 变为 N-1 台, 每 N(N-1)个数中, 只有(n-1)个单元,%N, %(N-得到相同的结果
所以 命中率在服务器 down 的短期内, 急剧下降至 (N-1)/(N*(N-1)) = 1/(N-1)
所以: 服务器越多, 则 down 机的后果越严重!


##### 一致性哈希算法
###### 原理
把各服务器节点映射放在钟表的各个时刻上, 把 key 也映射到钟表的某个时刻上. 该 key 沿钟表顺时针走,碰到的第 1 个节点即为该 key 的存储节点
例: 假设有abcd四个节点，平均分布在钟表上，即a0,b3c6d9, 有key要存储，key用相应的转化规则得到5，则key顺时针走，第一个遇到c6，则key存在c节点。
```
时钟只是为了便于理解做的比喻,在实际应用中,我们可以在圆环上分布[0,2^32-1]的数字。
可以自己设计转化规则,但注意转化后的碰撞率要低. 即不同的节点名,转换为相同的整数的概率要低.
```
###### 一致性哈希对其他节点的影响
当某个节点 down 后,只影响该节点顺时针之后的 1 个节点,而其他节点
不受影响.因此，Consistent Hashing 最大限度地抑制了键的重新分布

###### 虚拟节点
N 个真实节点,把每个真实节点映射成 M 个虚拟节点, 再把 M*N 个虚拟节点, 散列在圆环上. 各真实节点对应的虚拟节点相互交错分布
这样,某真实节点 down 后,则把其影响平均分担到其他所有节点上.